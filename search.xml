<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/13/hello-world/"/>
      <url>/2024/03/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>$$<br>c &#x3D; \sqrt{a^2 + b^2}<br>$$</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unrar</title>
      <link href="/2022/02/18/unrar/"/>
      <url>/2022/02/18/unrar/</url>
      
        <content type="html"><![CDATA[<h2 id="unrar"><a href="#unrar" class="headerlink" title="unrar"></a>unrar</h2><p>ubuntu 下双击解压 rar 压缩包，经常会因为错误解码而产生巨大的解压缩文件，导致解压失败。</p><p>需要使用单独的 <code>unrar</code> 命令来解压才不会出错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install unrar </span><br></pre></td></tr></table></figure><p>然后使用它来解压 <code>.rar</code> 压缩包，该命令有两个常用参数：</p><ul><li><code>x</code> : 将压缩包内的文件等解压到指定目录</li><li><code>e</code> : 解压到当前目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unrar x name.rar filepath</span><br><span class="line"></span><br><span class="line">unrar e name.rar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>open_sublime_at_command_line</title>
      <link href="/2022/01/23/open_sublime_at_command_line/"/>
      <url>/2022/01/23/open_sublime_at_command_line/</url>
      
        <content type="html"><![CDATA[<h2 id="open-sublime-at-command-line"><a href="#open-sublime-at-command-line" class="headerlink" title="open sublime at command line"></a>open sublime at command line</h2><p>在 ubuntu 下装了 sublime 后默认并不能通过运行命令的方式打开，这就让我们不能像 vim 一样可以通过 <code>vim &lt;fileName&gt;</code> 来打开文件。</p><p>不过可以通过把 sublime 的执行文件放到 PATH 目录下的方式实现用命令打开 sublime , 找到 sublime 的安装目录，一般是 <code>/opt/sublime_text</code> 。建立执行文件到 <code>/usr/local/bin</code> 的软连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/sublime_text/sublime_text /usr/local/bin/sublime</span><br></pre></td></tr></table></figure><p>这样在终端执行 <code>sublime &lt;fileName&gt;</code> 就可以用 sublime 打开文件了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>delete_kernels_at_ubuntu</title>
      <link href="/2022/01/23/delete_kernels_at_ubuntu/"/>
      <url>/2022/01/23/delete_kernels_at_ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="delete-kernels-at-ubuntu"><a href="#delete-kernels-at-ubuntu" class="headerlink" title="delete kernels at ubuntu"></a>delete kernels at ubuntu</h2><ol><li>查询当前系统版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version </span><br></pre></td></tr></table></figure><ol start="2"><li>找出系统已经安装的内核版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg --get-selections | grep linux-image</span><br></pre></td></tr></table></figure><ol start="3"><li>卸载旧的内核版本</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove linux-image-2.6.35-22-generic   //删除旧的内核,注意替换成上面列出的内核项目</span><br></pre></td></tr></table></figure><ol start="4"><li>重新启动：<code>reboot</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>download_files_with_curl</title>
      <link href="/2022/01/23/download_files_with_curl/"/>
      <url>/2022/01/23/download_files_with_curl/</url>
      
        <content type="html"><![CDATA[<h2 id="download-files-with-curl"><a href="#download-files-with-curl" class="headerlink" title="download files with curl"></a>download files with curl</h2><p>(curl 批量下载文件)</p><blockquote><p>curl(Client URL)是支持多种协议的用于数据传输的软件。</p></blockquote><p>curl支持的ftp http https等常见协议。</p><p>对于有些下载地址经常类似：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://abc.xyz/01.png</span><br><span class="line">https://abc.xyz/02.png</span><br><span class="line">...</span><br><span class="line">https://abc.xyz/99.png</span><br></pre></td></tr></table></figure><p>使用 curl 很方便的批量下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -C - -O https://abc.xyz/[01-99].png</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>-C - 断点续载</li><li>-O 下载的文件另存为 url 路径中的文件名<ul><li>-o custom-local-name</li></ul></li></ul><hr><p>批量下载会使用到的表达式有两种：</p><ul><li>{}</li><li>[]</li></ul><p>{a,b,c}会遍历 abc 三个元素。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://&#123;a,b,c&#125;.com/index.html</span><br></pre></td></tr></table></figure><p>会遍历：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/index.html</span><br><span class="line">https://b.com/index.html</span><br><span class="line">https://c.com/index.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>add_background_image_in_typora</title>
      <link href="/2022/01/23/add_background_image_in_typora/"/>
      <url>/2022/01/23/add_background_image_in_typora/</url>
      
        <content type="html"><![CDATA[<h2 id="add-background-image-in-typora"><a href="#add-background-image-in-typora" class="headerlink" title="add background image in typora"></a>add background image in typora</h2><p>找到 typora 主题的存储目录，创建 <code>images</code> 文件夹用于存放图片。</p><p>然后在所使用主题的相应 <code>.css</code> 文件中，在 <code>:root</code> 下添加背景的样式表参数：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">./images/image3.jpg</span>) -<span class="number">400px</span> <span class="number">0px</span> no-repeat;</span><br></pre></td></tr></table></figure><p><img src="/./images/2022012300000.png"></p><p>保存，重启 typora ，就会加载出刚刚指定的背景图片了。</p><blockquote><p>所有图片的参数属性，只要 css 有的，typora 应该都可以加载出来，都可以运用在背景图片上，比如透明度，又比如：<code>background-attachment: fixed;</code></p><p>通过自定义 <code>.css</code> 主题文件，即可实现自定义主题。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>get_matrix_inversion_in_numpy</title>
      <link href="/2022/01/23/get_matrix_inversion_in_numpy/"/>
      <url>/2022/01/23/get_matrix_inversion_in_numpy/</url>
      
        <content type="html"><![CDATA[<h2 id="get-matrix-inversion-in-numpy"><a href="#get-matrix-inversion-in-numpy" class="headerlink" title="get matrix inversion in numpy"></a>get matrix inversion in numpy</h2><h3 id="1-矩阵求逆"><a href="#1-矩阵求逆" class="headerlink" title="1. 矩阵求逆"></a>1. 矩阵求逆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a  = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])  <span class="comment"># 初始化一个非奇异矩阵(数组)</span></span><br><span class="line"><span class="built_in">print</span>(np.linalg.inv(a))  <span class="comment"># 对应于MATLAB中 inv() 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵对象可以通过 .I 更方便的求逆</span></span><br><span class="line">A = np.matrix(a)</span><br><span class="line"><span class="built_in">print</span>(A.I)</span><br></pre></td></tr></table></figure><h3 id="2-矩阵求伪逆"><a href="#2-矩阵求伪逆" class="headerlink" title="2. 矩阵求伪逆"></a>2. 矩阵求伪逆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个奇异阵 A</span></span><br><span class="line">A = np.zeros((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">A[<span class="number">0</span>, -<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">A[-<span class="number">1</span>, <span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">A = np.matrix(A)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># print(A.I)  将报错，矩阵 A 为奇异矩阵，不可逆</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.linalg.pinv(a))   <span class="comment"># 求矩阵 A 的伪逆（广义逆矩阵），对应于MATLAB中 pinv() 函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jupyter_notebook_Mistaken</title>
      <link href="/2022/01/23/jupyter_notebook_mistaken_delete_recovery/"/>
      <url>/2022/01/23/jupyter_notebook_mistaken_delete_recovery/</url>
      
        <content type="html"><![CDATA[<h2 id="jupyter-notebook-mistaken-delete-recovery"><a href="#jupyter-notebook-mistaken-delete-recovery" class="headerlink" title="jupyter notebook mistaken delete recovery"></a>jupyter notebook mistaken delete recovery</h2><p>在 jupyter notebook 上写了大段代码， 却不小心误删，同时由于 jupyter notebook 只有一个存档位， 代码没有存档，或存档过久， 因此无法恢复原内容。</p><p>但可以利用IPython强大的交互能力恢复出来！！</p><p>不要关 jupyter notebook , 而是继续执行下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">locals</span>()[<span class="string">&#x27;In&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者， 直接的</span></span><br><span class="line">history</span><br></pre></td></tr></table></figure><p>过往的输入历史就能很方便的显现出来， 然后手动恢复即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pytorch_load_model</title>
      <link href="/2022/01/23/pytorch_load_model/"/>
      <url>/2022/01/23/pytorch_load_model/</url>
      
        <content type="html"><![CDATA[<h2 id="pytorch-load-model"><a href="#pytorch-load-model" class="headerlink" title="pytorch load model"></a>pytorch load model</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>在已训练并保存在<code>CPU</code>上的<code>GPU</code>上加载模型时，加载模型时经常由于训练和保存模型时设备不同出现读取模型时出现错误，在对跨设备的模型读取时候涉及到两个参数的使用，分别是<code>model.to(device)</code>和<code>map_location=devicel</code>两个参数，简介一下两者的不同。</p><ul><li>将<code>map_location</code>函数中的参数设置 <code>torch.load()</code>为 <code>cuda：device_id</code>。这会将模型加载到给定的GPU设备。</li><li>调用<code>model.to(torch.device(&#39;cuda&#39;))</code>将模型的参数张量转换为<code>CUDA</code>张量，无论在<code>cpu</code>上训练还是<code>gpu</code>上训练，保存的模型参数都是参数张量不是<code>cuda</code>张量，因此，<code>cpu</code>设备上不需要使用<code>torch.to(torch.device(&quot;cpu&quot;))</code>。</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>了解了两者代表的意义，以下介绍两者的使用。</p><h4 id="1-保存在GPU，在CPU加载-most"><a href="#1-保存在GPU，在CPU加载-most" class="headerlink" title="1. 保存在GPU，在CPU加载 (most)"></a>1. 保存在GPU，在CPU加载 (most)</h4><p><strong>保存</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure><p><strong>加载</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH, map_location=device))</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><p>在使用<code>GPU</code>训练的<code>CPU</code>上加载模型时，请传递 <code>torch.device(&#39;cpu&#39;)</code>给<code>map_location</code>函数中的 <code>torch.load()</code>参数，使用<code>map_location</code>参数将张量下面的存储器动态地重新映射到<code>CPU</code>设备 。</p><h4 id="2-保存在GPU，在GPU加载"><a href="#2-保存在GPU，在GPU加载" class="headerlink" title="2. 保存在GPU，在GPU加载"></a>2. 保存在GPU，在GPU加载</h4><p><strong>保存</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure><p><strong>加载</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br><span class="line">model.to(device)</span><br><span class="line"><span class="comment"># Make sure to call input = input.to(device) on any input tensors that you feed to the model</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><p>在<code>GPU</code>上训练并保存在<code>GPU</code>上的模型时，只需将初始化<code>model</code>模型转换为<code>CUDA</code>优化模型即可<code>model.to(torch.device(&#39;cuda&#39;))</code>。此外，请务必<code>.to(torch.device(&#39;cuda&#39;))</code>在所有模型输入上使用该 功能来准备模型的数据。请注意，调用<code>my_tensor.to(device)</code> 返回<code>my_tensorGPU上</code>的新副本。它不会覆盖 <code>my_tensor</code>。因此，请记住手动覆盖张量： <code>my_tensor = my_tensor.to(torch.device(&#39;cuda&#39;))</code></p><h4 id="3-保存在CPU，在GPU加载"><a href="#3-保存在CPU，在GPU加载" class="headerlink" title="3. 保存在CPU，在GPU加载"></a>3. 保存在CPU，在GPU加载</h4><p><strong>保存：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH)</span><br></pre></td></tr></table></figure><p><strong>加载：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH, map_location=<span class="string">&quot;cuda:0&quot;</span>))  <span class="comment"># Choose whatever GPU device number you want</span></span><br><span class="line">model.to(device)</span><br><span class="line"><span class="comment"># Make sure to call input = input.to(device) on any input tensors that you feed to the model</span></span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>在已训练并保存在<code>CPU</code>上的<code>GPU</code>上加载模型时，请将<code>map_location</code>函数中的参数设置 <code>torch.load()</code>为 <code>cuda：device_id</code>。这会将模型加载到给定的GPU设备。接下来，请务必调用<code>model.to(torch.device(&#39;cuda&#39;))</code>将模型的参数张量转换为<code>CUDA</code>张量。最后，确保<code>.to(torch.device(&#39;cuda&#39;))</code>在所有模型输入上使用该 函数来为<code>CUDA</code>优化模型准备数据。请注意，调用 <code>my_tensor.to(device)</code>返回<code>my_tensorGPU</code>上的新副本。它不会覆盖<code>my_tensor</code>。因此，请记住手动覆盖张量：<code>my_tensor = my_tensor.to(torch.device(&#39;cuda&#39;))</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>install_pybulez</title>
      <link href="/2021/11/23/install_pybulez/"/>
      <url>/2021/11/23/install_pybulez/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-pybluez"><a href="#安装-pybluez" class="headerlink" title="安装 pybluez"></a>安装 pybluez</h2><p>想着写一个跨设备通讯的程序，但又不想用网络，这就想到通过蓝牙来实现。</p><p>python 有针对蓝牙通讯的包 pybluez 。</p><p>本文件记录在 Ubuntu 下安装 pybluez 包的过程。</p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pybluez</span><br></pre></td></tr></table></figure><p>直接运行 pip 安装指令，然后报错：</p><p><img src="/./images/error_of_install_pybluez.png" alt="error"></p><p>缺少相关依赖，查找后得到解决办法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libbluetooth-dev</span><br><span class="line">pip install pybluez</span><br></pre></td></tr></table></figure><p>安装成功！</p><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bluetooth</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;本机蓝牙MAC地址:&quot;</span>, bluetooth.read_local_bdaddr())</span><br></pre></td></tr></table></figure><p>查看本地蓝牙 MAC 地址：成功！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(discover_devices(lookup_names=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><p>查看可通讯蓝牙列表：测试失败，凑！</p><h3 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h3><p>安装成功，测试失败，若有闲暇，再来送菜。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>conda-delete-base</title>
      <link href="/2021/10/25/conda-delete-base/"/>
      <url>/2021/10/25/conda-delete-base/</url>
      
        <content type="html"><![CDATA[<h2 id="安装conda后取消命令行前出现的base，取消每次启动自动激活conda的基础环境"><a href="#安装conda后取消命令行前出现的base，取消每次启动自动激活conda的基础环境" class="headerlink" title="安装conda后取消命令行前出现的base，取消每次启动自动激活conda的基础环境"></a>安装conda后取消命令行前出现的base，取消每次启动自动激活conda的基础环境</h2><p>方法一：</p><p>每次在命令行通过<code>conda deactivate</code>退出<code>base</code>环境回到系统自带的环境</p><p>方法二</p><ol><li>通过将<code>auto_activate_base</code>参数设置为<code>false</code>实现：</li></ol><p><code>conda config --set auto_activate_base false</code></p><ol start="2"><li><p>那要进入的话通过<code>conda activate base</code></p></li><li><p>如果反悔了还是希望<code>base</code>一直留着的话通过<code>conda config --set auto_activate_base true</code>来恢复</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>federated-learning-cartoons</title>
      <link href="/2021/10/09/federated-learning-cartoons/"/>
      <url>/2021/10/09/federated-learning-cartoons/</url>
      
        <content type="html"><![CDATA[<h2 id="联邦学习漫画"><a href="#联邦学习漫画" class="headerlink" title="联邦学习漫画"></a>联邦学习漫画</h2><p>谷歌 Google I&#x2F;O’19 出品，关于联邦学习的中文小漫画。在保护用户隐私以及提供更加智能的服务时，不一定会陷入 “鱼与熊掌不可兼得” 的困境。</p><img src="images/640" alt="640?wx_fmt=png" style="zoom:140%;" />![640?wx_fmt=png](images/640-16337868236752)![640?wx_fmt=png](images/640-16337868431994)![640?wx_fmt=png](images/640-16337868480156)![640?wx_fmt=png](images/640-16337868533168)![640?wx_fmt=png](images/640-163378685753410)![640?wx_fmt=png](images/640-163378686146712)![640?wx_fmt=png](images/640-163378686614514)![640?wx_fmt=png](images/640-163378687166416)![640?wx_fmt=png](images/640-163378687709018)![640?wx_fmt=png](images/640-163378691289520)![640?wx_fmt=png](images/640-163378692007322)![640?wx_fmt=png](images/640-163378692816224)![640?wx_fmt=png](images/640-163378693432926)![640?wx_fmt=png](images/640-163378694041628)![640?wx_fmt=png](images/640-163378694547630)![640?wx_fmt=png](images/640-163378695067832)![640?wx_fmt=png](images/640-163378695554734)![640?wx_fmt=png](images/640-163378696118236)![640?wx_fmt=png](images/640-163378696746138)![640?wx_fmt=png](images/640-163378697295440)![640?wx_fmt=png](images/640-163378697960242)![640?wx_fmt=png](images/640-163378700064044)![640?wx_fmt=png](images/640-163378700515146)![640?wx_fmt=png](images/640-163378700965048)![640?wx_fmt=png](images/640-163378702253450)![640?wx_fmt=png](images/640-163378703705052)![640?wx_fmt=png](images/640-163378722113454)![640?wx_fmt=png](images/640-163378723785656)![640?wx_fmt=png](images/640-163378724402058)![640?wx_fmt=png](images/640-163378725509860)![640?wx_fmt=png](images/640-163378726145862)![640?wx_fmt=png](images/640-163378726659564)<p><img src="/images/640-163378727844566" alt="640?wx_fmt=png"><img src="/images/640-163378728360168" alt="640?wx_fmt=png"></p><ul><li><strong>安全聚合</strong>是一种用于计算带掩码的矢量 (比如模型里的权重) 之和的交互式加密协议。它会调整数据对中的随机掩码，使得当输入的数据足够多时，让这些掩码最终相互抵消，从而计算出最终结果 (如一套计算模型的更新量)。</li><li>Practical Secure Aggregation for Privacy-Preserving Machine Learning</li><li><a href="https://ai.google/research/pubs/pub47246">https://ai.google/research/pubs/pub47246</a></li></ul><p><img src="/images/640-163378733052470" alt="640?wx_fmt=png"><img src="/images/640-163378733667572" alt="640?wx_fmt=png"><img src="/images/640-163378734298774" alt="640?wx_fmt=png"><img src="/images/640-163378734890376" alt="640?wx_fmt=png"></p><p><img src="/images/640-163378735788178" alt="640?wx_fmt=png"><img src="/images/640-163378736430580" alt="640?wx_fmt=png"><img src="/images/640-163378736950982" alt="640?wx_fmt=png"><img src="/images/640-163378737523984" alt="640?wx_fmt=png"><img src="/images/640-163378738377986" alt="640?wx_fmt=png"><img src="/images/640-163378739091888" alt="640?wx_fmt=png"><img src="/images/640-163378739974190" alt="640?wx_fmt=png"><img src="/images/640-163378740657392" alt="640?wx_fmt=png"><img src="/images/640-163378741609394" alt="640?wx_fmt=png"><img src="/images/640-163378742558996" alt="640?wx_fmt=png"><img src="/images/640-163378743379398" alt="640?wx_fmt=png"><img src="/images/640-1633787442466100" alt="640?wx_fmt=png"></p><ul><li><strong>联盟学习与分析</strong>基于多个领域的丰富研究成果，包括分布式优化、机器学习以及隐私研究。而且借鉴了很多系统和工具的灵感，比如用于分布式计算的 MapReduce，用于机器学习的 TensorFlow 以及用于隐私保护与分析的 RAPPOR。使用联盟学习来训练深度网络的论述最早由 Google AI 研究人员于 2016 年发表。</li><li>Communication-Efficient Learning of Deep Networks from Decentralized Data</li><li><a href="https://arxiv.org/abs/1602.05629">https://arxiv.org/abs/1602.05629</a></li></ul><p><img src="/images/640-1633787481471102" alt="640?wx_fmt=png"><img src="/images/640-1633787487762104" alt="640?wx_fmt=png"><img src="/images/640-1633787495261106" alt="640?wx_fmt=png"><img src="/images/640-1633787501458108" alt="640?wx_fmt=png"><img src="/images/640-1633787508274110" alt="640?wx_fmt=png"><img src="/images/640-1633787514592112" alt="640?wx_fmt=png"><img src="/images/640-1633787520150114" alt="640?wx_fmt=png"><img src="/images/640-1633787526429116" alt="640?wx_fmt=png"><img src="/images/640-1633787534043118" alt="640?wx_fmt=png"><img src="/images/640-1633787540892120" alt="640?wx_fmt=png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>federated-learning</title>
      <link href="/2021/10/08/federated-learning/"/>
      <url>/2021/10/08/federated-learning/</url>
      
        <content type="html"><![CDATA[<h2 id="联邦学习"><a href="#联邦学习" class="headerlink" title="联邦学习"></a>联邦学习</h2><p>21 世纪初，人工智能进入以深度学习为主导的大数据时代，基于大数据的机器学习既推动了 AI 的蓬勃发展，也带来了一系列安全隐患。这些隐患来源于深度学习本身的学习机制，无论是在它的模型训练阶段，还是在模型预测(推理)和使用阶段。这些安全隐患如果被有意或无意地滥用，后果将十分严重。当前 AI 安全已引起人们普遍的关注，各项的治理措施也因此积极开展。AI 治理有以下几个不同的维度，即技术、法律、经济和文化等。</p><p>“<strong>联邦学习</strong>”(Federated Learning)正是在这个背景下提出和发展起来的，它主要从技术维度出发，重点研究其中的隐私保护和数据安全问题。联邦学习保护隐私和数据安全包括两个过程，分别是模型训练和模型预测。在模型训练阶段，模型相关的信息可以在各方之间交换，但数据不能交换，因此各个站点上的数据将受到保护。在模型预测阶段，训练好的联邦学习模型可以置于联邦学习系统的各参与方，也可以供多方共享。</p><p>联邦学习既能帮助多个参与方搭建共享的高新能模型，又符合用户隐私和数据保密性的要求。</p><p>联邦学习技术的推进，需要多个学科领域的合作，包括机器学习算法、分布式机器学习、密码学与安全、隐私保护、数据挖掘、博弈论与经济学原理、激励机制设计、法律与监管等。</p><p><strong>人工智能面临的挑战</strong></p><p>随着人工智能的不断落地，在未来，不同组织之间进行数据的整合工作将是极大的挑战。由此，如何在遵守更加严格的、新的隐私保护条例的前提下，解决数据碎片化和数据隔离的问题，是当前人工智能所要面临的首要挑战。$\rfloor$</p><p>由于各种原因造成的数据孤岛，正阻碍着训练人工智能模型所必需的大量数据的使用，所以就需要寻求一种新的方式，不必将所有数据集中到一个中心存储点就能训练机器学习模型。</p><p>一种可行的方法是由每一个拥有数据源的组织训练一个模型，之后各个组织在各自的模型上交流(传输数据向传输模型参数的改变)，最终通过模型聚合得到一个全局模型。为了确保用户隐私和数据安全，各组织间交换模型信息的过程将会被特殊加密，使得没有哪一个组织可以猜测到或反向推导出其他任何组织的隐私数据内容。同时，当构建全局模型时，各数据源仿佛已被整合在一起，这便是联邦机器学习（Federated Machine Learning）或者简称联邦学习（Federated Learning）的核心思想。</p><p>谷歌的联邦学习系统很好的展示了企业对消费者 （Business-to-Consumer）即 B2C 的一个应用案例，它为 B2C 的应用设计了一种安全的分布式计算环境。在 B2C 场景下，由于边缘设备和中央服务器之间传输信息的速度加快，联邦学习可以确保隐私保护和更高的模型性能。</p><p><img src="/images/B2C.png" alt="B2C"></p><p>综上，联邦学习旨在建立一个基于分布数据集的联邦学习模型。</p><p><img src="/images/P2P.png" alt="P2P"></p><h3 id="联邦学习分类"><a href="#联邦学习分类" class="headerlink" title="联邦学习分类"></a>联邦学习分类</h3><p>设矩阵 $D_i$ 表示第 $i$ 个参与方的数据；设矩阵 $D_i$ 的每一行表示一个数据样本，每一列表示一个具体的数据特征。一些数据集还可能包含标签信息。</p><p>将特征空间设为 $\mathcal{X}$ ，数据标签空间设为 $\mathcal{Y}$ ，并用 $\mathcal{I}$ 表示数据样本 $ID$ 空间。这三者就组成了一个训练数据集 $(\mathcal{I,X,Y})$  。</p><p>不同的参与方之间的数据的特征空间与样本 $ID$ 空间可能是不同的。根据训练数据在不同参与方之间的数据特征和样本 $ID$ 空间的分布情况，可以将联邦学习划分为三类，即：</p><ul><li>横向联邦学习（Horizontal Federated Learning, HFL）</li><li>纵向联邦学习（Vertical Federated Learning, VFL）</li><li>迁移联邦学习（Federated Transfer Learning, FTL）</li></ul><p>横向联邦学习适用于联邦学习的参与方的数据有重叠的数据特征的情形，即数据特征在参与方之间是对齐的，但参与方拥有的数据样本是不同的。它类似于在表格试图中将数据水平划分的情况。因此，横向联邦学习有时也称为按样本划分的联邦学习。</p><p><img src="/images/HFL.png" alt="HFL"></p><p>与横向不同，纵向联邦学习适用于联邦学习参与方的训练数据有重叠的数据样本，即参与方之间的数据样本是对齐的，但是在数据特征上有所不同。它类似与数据在表格视图中将数据垂直划分的情况。因此，纵向联邦学习有时也称按特征划分的联邦学习。</p><p><img src="/images/VFL.png" alt="VFL"></p><p>联邦迁移学习则适用于参与方的数据样本和数据特征重叠都很少的情况。</p><p><img src="/images/FTL.png" alt="FTL"></p><h3 id="面对隐私保护的机器学习"><a href="#面对隐私保护的机器学习" class="headerlink" title="面对隐私保护的机器学习"></a>面对隐私保护的机器学习</h3><p>不断发生的数据泄密和隐私侵权事件使得社会公众更加认识到，在人工智能系统的构建与使用过程中，需要保护用户隐私和数据机密性。近来，研究人员们正着眼于开发能够在机器学习系统中使用的隐私保护技术，由此产生的系统便称作面向隐私保护的机器学习（Privacy-Preserving Machine Learning, PPML）系统。</p><p>PPML 中有一些著名方法，包括但不限于：安全多方计算（Secure Multi-party Computation, MPC）、供隐私保护模型训练和预测使用的同态加密方法（Homomorphic Encryption, HE）和用于防止数据泄密的差分隐私（Differential Privacy, DP）方法。分布式机器学习中还有隐私保护梯度下降的方法。</p><h4 id="面向隐私保护的机器学习与安全机器学习"><a href="#面向隐私保护的机器学习与安全机器学习" class="headerlink" title="面向隐私保护的机器学习与安全机器学习"></a>面向隐私保护的机器学习与安全机器学习</h4><p>PPML 与安全机器学习（Secure ML）的区别主要是在于它们被设计用来应对不同类型的安全威胁。在安全机器学习中，敌手（抑或攻击者）被假设违反了机器学习系统的完整性和可用性。而在 PPML 中，敌手被假设违反了机器学习系统的隐私性和机密性。</p><p>有时安全方面的危机是由第三方故意攻击造成的。下面是机器学习中被关注的三种主要攻击类型：</p><ol><li>完整性（Integrity）</li></ol><p>对完整性的攻击可能导致机器学习系统会出现检测错误，例如可能会将入侵点检测为正常（假阴性）。</p><ol start="2"><li>可用性（Availability）</li></ol><p>对可用性的攻击可能导致系统会出现分类错误（假阴性和假阳性），即系统会变成不可用。这是比完整性攻击更宽泛的一种攻击类型。</p><ol start="3"><li>机密性（Confidentiality）</li></ol><p>对机密性的攻击可能导致一些机器学习系统中的敏感信息（如训练数据或训练模型）会出现泄密。</p><p>下表给出了 PPML 和安全机器学习在安全威胁、攻击模式和防御方法上的比较。</p><table><thead><tr><th align="center"></th><th>安全威胁</th><th>攻击模式</th><th>防御方式</th></tr></thead><tbody><tr><td align="center">PPML</td><td>隐私性<br />机密性</td><td>重构攻击<br />模型反演攻击<br />成员推理攻击</td><td>安全多方计算<br />同态加密<br />差分隐私</td></tr><tr><td align="center">安全机器学习</td><td>完整性<br />可用性</td><td>投毒攻击<br />对抗攻击<br />询问攻击</td><td>防御精馏<br />对抗训练<br />正则化</td></tr></tbody></table><h4 id="威胁与安全模型"><a href="#威胁与安全模型" class="headerlink" title="威胁与安全模型"></a>威胁与安全模型</h4><p>为了在机器学习中保护隐私和完整性，有必要理解可能的安全威胁模型。在机器学习任务中，参与方通常会扮演三种不同的角色：</p><ul><li>输入方，如数据的原始拥有者</li><li>计算方，如模型建立者和推理服务提供者</li><li>结果方，如模型查询者和用户</li></ul><p>对机器学习系统的攻击可能在任何阶段发生，包括数据发布、模型训练和模型推理。在模型训练阶段发生的攻击叫作<strong>重构攻击</strong>（Reconstruction Attacks）。计算方的目的是重构数据提供者的原始数据，或者学习关于数据的更多信息，而不是最终模型所提供的信息。重构攻击是联邦学习的主要隐私关注点。在模型推理阶段，一个敌对的结果方可能会使用反向工程技术来获取模型的额外信息，以此实施<strong>模型反演攻击</strong>（Model Inversion Attacks）或<strong>成员推理攻击</strong>（Membership-Inference Attacks）。<strong>特征推理攻击</strong>（Attribute-Inference Attacks）则发生在数据分布阶段。</p><p>对于密码学 PPML 技术，包括安全多方计算和同态加密，现有研究工作涉及两种类型的敌手：</p><ul><li><strong>半诚实的(Semi-honest)敌手</strong>：在半诚实（抑或诚实但好奇的、被动的）敌手模型中，敌手诚实地遵守协议，但也会试图从接收到的信息中学习更多除输出以外的信息</li><li><strong>恶意的(Malicious)敌手</strong>：在恶意的（抑或主动的）敌手模型中，敌手不遵守协议，可以执行任意的攻击行为</li></ul><h4 id="隐私保护技术"><a href="#隐私保护技术" class="headerlink" title="隐私保护技术"></a>隐私保护技术</h4><p>常用的隐私保护技术有三种：安全多方计算、同态加密和差分隐私。</p><p>在安全多方计算中，目的是协同地从每一方的隐私输入中计算函数的结果，而不用将这些输入展示给其他方。通常情况下，安全多方计算能够通过三种不同的框架来实现：不经意传输、秘密共享和阈值同态加密。从某种程度上讲，不经意传输协议和阈值同态加密方法都使用了秘密共享的思想。</p><p>同态加密逐渐被认为是在 PPML 中实现安全多方计算的一种可行方法。同态加密方法是一种通过对相关密文进行有效操作（不需要获知解密秘钥），从而允许在加密内容上进行特定代数运算的加密方法。简单来说就是将数据加密，再对密文进行各种代数运算，最后再将得到的结果按照秘钥进行解密，得到的结果相当于直接在原数据上进行代数运算得到的结果。同态加密方法主要分为三类：部分同态加密、些许同态加密和全同态加密。</p><p>差分隐私的中心思想是，当敌手试图从数据库中查询个体信息时将其混淆，使得敌手无法从查询结果中辨别个体级别的敏感性。主要有两种方法通过给数据加上噪声实现差分隐私，一种是根据函数的敏感性增加噪声，一种是根据离散值的指数分布选择噪声。差分隐私算法可根据噪声扰动使用的方法和位置来进行分类。</p><ul><li>输入扰动：噪声被加入训练数据</li><li>目标扰动：噪声被加入学习算法的目标函数</li><li>算法扰动：噪声被加入中间值，例如迭代算法中的梯度</li><li>输出扰动：噪声被加入训练后的输出参数</li></ul><h3 id="分布式机器学习"><a href="#分布式机器学习" class="headerlink" title="分布式机器学习"></a>分布式机器学习</h3><p>分布式机器学习（Distributed Machine Learning）</p><p>一些著名的面向拓展性的 DML 方案，包括数据并行、模型并行、图并行、任务并行、混合并行和交叉并行。</p><p>在面向隐私的 DML 中，常用的用于保护数据隐私的方法大概分为以下两个类别：</p><ul><li>模糊处理。随机化、添加噪声或修改数据使其拥有某一级别的隐私，如差分隐私方法</li><li>密码学方法。通过不将输入值传给其他参与方的方式或者不以明文方式传输，使分布式计算过程安全化，如多方加密计算，包括不经意传输、秘密共享、混淆电路和同态加密</li></ul><h3 id="横向联邦学习"><a href="#横向联邦学习" class="headerlink" title="横向联邦学习"></a>横向联邦学习</h3><p>横向联邦学习也称按样本划分的联邦学习，可以应用于联邦学习的各个参与方的数据集有相同的特征空间和不同的样本空间的场景，类似于在表格视图中对数据进行水平划分的情况。例如表格中的记录按照行被横向划分为不同的组，且每行都包含完整的数据特征。</p><p>举例来说，两个地区的城市商业银行可能在各自的地区拥有非常不同的客户群体，所以他们的客户交集非常小，他们的数据集有不同的样本 $ID$ 。然而，他们的业务模型非常相似，因此他们的数据集的特征空间是相同的。这两家银行可以联合起来进行横向联邦学习以构建更好的风控模型。</p><p>确切的说，可以将横向联邦学习的条件总结为：<br>$$<br>\mathcal{X}_i &#x3D; \mathcal{X}_j,<del>\mathcal{Y}_i &#x3D; \mathcal{Y}_j,</del>\mathcal{I}_i \neq \mathcal{I}_j,<del>\forall \mathcal{D}_i,</del>\mathcal{D_j},~i\neq j,<br>$$<br>式中，$\mathcal{D}_i$ 和 $\mathcal{D}_j$ 分别表示第 $i$ 方和第 $j$ 方拥有的数据集。建设两方的数据特征空间和标签空间对，即 $(\mathcal{X}_i,\mathcal{Y}_i)$ 和 $(\mathcal{X}_j, \mathcal{Y}_j)$ 是相同的。但建设两方的客户 $ID$ 空间，即 $\mathcal{I}_i$ 和 $\mathcal{I}_j$ 是没有交集或交集很小。</p><p>关于横向联邦学习系统的安全性的定义，通常假设一个横向联邦学习系统的参与方都是诚实的，需要防范的对象是一个诚实但好奇的聚合服务器。即通常假设只有服务器才能使得数据参与方的隐私安全受到威胁。</p><p>前期提出的横向联邦学习的架构一般都没有提供安全性的证明。当联邦模型训练结束时，聚合模型和整个模型的参数都会暴露给所有的参与方。</p><h4 id="横向联邦学习架构"><a href="#横向联邦学习架构" class="headerlink" title="横向联邦学习架构"></a>横向联邦学习架构</h4><h5 id="客户-服务器架构（client-server）"><a href="#客户-服务器架构（client-server）" class="headerlink" title="客户-服务器架构（client-server）"></a>客户-服务器架构（client-server）</h5><p>典型的横向联邦学习系统的客户-服务器架构如下图所示，也被称为主-从(master-worker)架构或者轮辐式(hub-and-spoke)架构。在这种系统中，具有同样的数据结构的 $K$ 个参与方（也叫作客户或用户）在服务器（也叫参数服务器或者聚合服务器）的帮助下，协作地训练一个机器学习模型。</p><p><img src="/images/%E5%AE%A2%E6%88%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84.png" alt="客户-服务器"></p><p>横向联邦学习系统的训练过程通常由如下四步组成：</p><ol><li>各参与方在本地计算模型梯度，并使用同态加密、差分隐私或秘密共享等加密技术，对梯度信息进行掩饰，并将掩饰后的结果（简称为加密梯度）发送给聚合服务器。</li><li>服务器进行安全聚合操作，如使用基于同态加密的加权平均。</li><li>服务器将聚合后的结果发送给各参与方。</li><li>各参与方对收到的梯度进行解密，并使用解密后的梯度结果更新各自的模型参数。</li><li>迭代 1~4 直到损失函数收敛或者达到允许的迭代次数的上限或允许的训练时间。</li></ol><p>这种架构独立于特定的机器学习算法，并且所有参与方将会共享最终的模型参数。需要注意的是，上述步骤中参与方将梯度信息发送给服务器，服务器将收到的梯度信息进行聚合（例如计算加权平方），再将聚合的梯度信息发送给参与方。称这种方法为<strong>梯度平均</strong>。除了共享梯度信息，联邦学习的参与方 还可以共享模型的参数。参与方在本地计算模型参数，并将它们发送至服务器。服务器对收到的模型参数进行聚合（如计算加权平均），再将聚合的模型参数发送给参与方。称这种办法为<strong>模型平均</strong>。</p><p>在某些条件下，例如模型参数在参与方每次更新之后进行聚合，此时模型平均等价于梯度平均。下表比较了两种平均方式。模型平均和梯度平均在文献中都被称为联邦平均算法。</p><table><thead><tr><th align="center">方法</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">梯度平均</td><td align="center">准确的梯度信息<br />有保证的收敛</td><td align="center">加重通讯负担<br />需要可靠连接</td></tr><tr><td align="center">模型平均</td><td align="center">不受SGD限制<br />可以容忍更新缺失<br />不频繁的同步</td><td align="center">不保证收敛<br />性能损失</td></tr></tbody></table><p>如果联邦平均算法使用了安全多方计算或加法同态加密技术，则上述架构能防范半诚实的服务器的攻击，并防止数据泄露。然而，在协同学习过程中，若有一个恶意的参与方训练生成对抗网络，将可能导致系统容易遭受攻击。</p><h5 id="对等网络架构（Peer-to-Peer-P2P）"><a href="#对等网络架构（Peer-to-Peer-P2P）" class="headerlink" title="对等网络架构（Peer-to-Peer,P2P）"></a>对等网络架构（Peer-to-Peer,P2P）</h5><p>横向联邦学习系统也能够利用对等网络架构，如下图所示。在该架构下，不存在中央服务器或者协调方。在这种架构中，横向联邦学习系统的 $K$ 个参与方也被称为训练方或分布式训练方。每一个训练方负责只使用本地数据来训练同一个机器学习模型（如 DNN 模型）。此外，训练方们使用安全链路在相互之间传输模型参数信息。为了保证任意两方之间的通信安全，需要使用例如基于公共秘钥的加密方法等安全措施。</p><p><img src="/images/P2P%E6%9E%B6%E6%9E%84.png" alt="P2P"></p><p>由于对等网络架构中不存在中昂服务器，训练方们必须提前商定发送和接收模型参数信息的顺序，主要有两种方法可以达到这个目的：</p><ul><li>循环传输</li><li>随机传输</li></ul><h5 id="全局模型评估"><a href="#全局模型评估" class="headerlink" title="全局模型评估"></a>全局模型评估</h5><p>在横向联邦学习中，模型训练和评估是在每个参与方中分布地执行的，并且任意方都不能获取其他方的数据集。所以，每个参与方都能轻易地使用自己的本地测试数据集来测试本地模型的性能，但得到全局模型的性能评价需要消耗更多资源。在这里，本地模型性能表示某一参与方在本地测试数据集上检验得出的横向联邦学习模型的性能，全局模型性能表示所有参与方在测试数据集上对横向联邦学习模型进行测试得出的模型性能。</p><p>模型性能仍表现为精确度、准确度和召回率等，只是需要统计所有参与方的数据进而得到全局量。</p><h4 id="联邦平均算法"><a href="#联邦平均算法" class="headerlink" title="联邦平均算法"></a>联邦平均算法</h4><p>联邦平均算法（FedAvg）被提出用于横向联邦学习的模型训练。为了区别与并行小批量随机梯度下降算法（parallel mini-batch SGD），联邦平均算法也被称为并行重启的随机梯度下降算法（parallel restarted SGD）或者 local SGD .</p><p>对于联邦学习，有区别与分布式优化问题的一些其他问题，包括：</p><ul><li>数据集的非独立同分布</li><li>不平衡的数据量</li><li>数量很大的参与方</li><li>慢速且不稳定的通信连接</li></ul><p>对于许多模型而言，计算代价相比于通信代价是微乎其微的。所以，可以使用额外的计算，以减少训练模型所需的通信轮次。联邦学习算法允许使用包括但不限于以下两种来增加计算：</p><ul><li>增加并行度。加入更多的参与方，让它们在通信轮次间各自独立地进行模型训练</li><li>增加每一个参与方中的计算。每一个参与方可以在两个通信轮次间进行更复杂的计算，例如进行多次本地模型更新迭代</li></ul><p>下图是联邦平均算法的伪代码复现。<a href="https://arxiv.org/abs/1602.05629v3">文献</a></p><p><img src="/images/4-2.png" alt="4-2"></p><p>但上述算法会暴露中间结果的明文内容，即它没有对数据传输提供任何安全保护。可以利用隐私保护技术来改进该算法，比如使用加法同态加密。</p><p><img src="/images/4-2.png" alt="4-2"></p><p>联邦平均算法的改进方向：</p><ul><li>通信效率提升<ul><li>压缩的模型参数更新</li><li>结构化的模型参数更新</li></ul></li><li>参与方选择</li></ul><h3 id="纵向联邦学习"><a href="#纵向联邦学习" class="headerlink" title="纵向联邦学习"></a>纵向联邦学习</h3><p>横向联邦学习（HFL）适用于参与方的数据集具有相同的特征空间、不同的样本空间的场景。在这些场景下，联邦的目标是应用的消费者群体，可以将其视为企业对消费者（B2C）范式。然而，在许多实际场景中，联邦学习的参与方是拥有同一用户群体的组织或机构。这些组织针对同一群体收集不同的数据特征以实现不同的业务目标。他们为了提高业务效率，通常有很强的合作意向，这可以被视作企业对企业（B2B）范式。</p><p>把在数据集上具有相同的样本空间、不同的特征空间的参与方所组成的联邦学习归类为纵向联邦学习，也可以理解为按特征划分的联邦学习。</p><p>出于不同的商业目的，不同组织拥有的数据集通常具有不同的特征空间，但这些组织可能共享一个巨大的用户群体，如下图所示。</p><p><img src="/images/VFL.png" alt="VFL"></p><p>通过使用 VFL ，可以利用分布于这些组织的异构数据，搭建更好的机器学习模型，并且不需要交换和泄露隐私数据。在这种联邦学习体系下，每一个参与方的身份和地位是相同的。联邦学习帮助所有参与方建立起一个“共同获益”的策略。</p><p>对于这样的纵向联邦学习系统，有：<br>$$<br>\mathcal{X}_i \neq \mathcal{X}_j , ~<br>\mathcal{Y}_i \neq \mathcal{Y}_j , ~<br>\mathcal{I}_i &#x3D; \mathcal{I}_j , ~<br>\forall \mathcal{D}_i,\mathcal{D}_j, i \neq j,<br>$$<br>式中，$\mathcal{X}$ 表示特征空间；$\mathcal{Y}$ 表示标签空间；$\mathcal{I}$ 是样本 $ID$ 空间；$\mathcal{D}$ 表示由不同参与方拥有的数据集。纵向联邦学习的目的是，通过利用由参与方收集的所有特征，协作地建立起一个共享的机器学习模型。</p><p>在 VFL 的设置中，存在一些关于实现安全和隐私保护的假设。首先 VFL 假设参与方都是诚实但好奇的。这意味着参与方虽然遵守安全协议，但将会尝试通过从其他参与方处获得的信息，尽可能多地推理出信息中包含的具体内客。由于各参与方也想要搭建一个更加精确的模型，所以他们相互之间不会共谋。第二，VFL 假设信息的传输过程是安全且足够可靠的，能够抵御攻击。此外，还假设通信是无损的，不会使得中间结果的内容发生变化。一个半诚实的第三方（Semi-honest Third Party. STP）可能会被引入来帮助参与方进行安全的联邦学习。STP 独立于各参与方，它将会收集中间结果以计算梯度和损失值，并将结果转发给每一参与方。STP 收到的来自参与方的信息是被加密过或者被混淆处理过的。因此各方的原始数据并不会暴露给彼此，并且各参与方只会收到与其拥有的特征相关的模型参数。</p><p>关于 VFL 系统的安全定义，假设一个 VFL 系统中存在诚实但好奇的参与方。 例如，在一个两方场景中，双方不会共谋且最多有一个参与方被敌对方破坏。安全定义是指敌对方只能从其破坏的参与方拥有的数据上进行学习，而不能访问到其他参与方的数据。为了使两方之间的安全计算更加便利，有时会加入一个 STP ，并假设该 STP 不会与任一方共谋。MPC 提供了这些协议的正式隐私证明。在学习过程的最后，每一个参与方只会拥有与自己的特征相关的模型参数，因此在推理过程中，两方也需要协作地生成输出结果。</p><h4 id="纵向联邦学习的架构"><a href="#纵向联邦学习的架构" class="headerlink" title="纵向联邦学习的架构"></a>纵向联邦学习的架构</h4><p>为了易于描述，下面用一个例子来说明 VFL 的架构。假设有两家公司 A 和 B 想要协同地训练一个机器学习模型。每一家公司都拥有各自的数据，此外 B 方还拥有进行模型预测任务所需的标注数据。由于用户隐私和数据安全的原因，A 方和 B 方不能直接交换数据。为了保证训练过程中的数据保密性，加入了一个第三方的协调者 C 。在这里，我们假设 C 方是诚实的且不与 A 方或 B 方共谋，但 A 方和 B 方都是诚实但好奇的。被信任的第三方 C 是一个合理的假设，因为 C 方的角色可以由权威机关（如政府）扮演或由安全计算节点代替。纵向联邦学习的一个例子在下图左侧展示。VFL 系统的训练过程一般由两部分组成：首先对其具有相同 $ID$ ，但分布不同参与方的实体；然后基于这些已对其的实体执行加密（或隐私保护的）模型训练。</p><p><img src="/images/VFL1.png" alt="VFL1"></p><ol><li>第一部分:加密实体对齐</li></ol><p>由于 A 方和 B 方公司的用户群体不同，系统使用一种基于加密的用户 ID 对齐技术，来确保 A 方和 B 方不需要暴露各自的原始数据便可以对齐共同用户。在实体对齐期间，系统不会将属于某一家公司的用户暴露出来，如下图所示。</p><p><img src="/images/5-2.png" alt="5-2"></p><ol start="2"><li>第二部分:加密模型训练</li></ol><p>在确定共有实体后,各方可以使用这些共有实体的数据来协同地训练一个机器学 习模型。训练过程可以被分为以下四个步骤，如图 5-1(b) 所示。 </p><ul><li>步骤1 协调者 C 创建密钥对，并将公共密钥发送给 A 方和 B 方。</li><li>步骤2 A 方和 B 方对中间结果进行加密和交换。中间结果用来帮助计算梯度和损失值。 </li><li>步骤3 A 方和 B 方计算加密梯度并分别加入附加掩码(additional mask)。B 方还会计算加密损失。A 方和 B 方将加密的结果发送给 C 方。 </li><li>步骤4 C 方对梯度和损失信息进行解密，并将结果发送回 A 方和 B 方。A 方 B 方解除梯度信息上的掩码，并根据这些梯度信息来更新模型参数。</li></ul><h4 id="纵向联邦学习算法"><a href="#纵向联邦学习算法" class="headerlink" title="纵向联邦学习算法"></a>纵向联邦学习算法</h4><h5 id="安全联邦线性回归"><a href="#安全联邦线性回归" class="headerlink" title="安全联邦线性回归"></a>安全联邦线性回归</h5><p>这种算法利用同态加密方法，在联邦线性回归模型的训练过程中保护属于每一个参与方的本地数据。</p><p><img src="/images/%E7%AC%A6%E5%8F%B7%E8%A1%A8.png" alt="符号表"></p><p>安全联邦线性回归模型的训练步骤如下：</p><p><img src="/images/%E5%AE%89%E5%85%A8%E8%81%94%E9%82%A6%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.png" alt="安全联邦线性回归"></p><p>安全联邦线性回归模型的预测步骤如下：</p><p><img src="/images/5-3.png" alt="5-2"></p><h5 id="安全联邦提升树"><a href="#安全联邦提升树" class="headerlink" title="安全联邦提升树"></a>安全联邦提升树</h5><p>安全联邦提升树在 VFL 的设定下对 SecureBoost 进行了研究。研究表明了 SecureBoost 与需要将数据收集与一处的非联邦梯度提升树算法具有相同的精确度。换句话说，SecureBoost 可与不具有隐私保护功能的且在非联邦设定下的相同算法提供相同的精确度。需要注意的是，<a href="http://arxiv.org/abs/1901.08755">文献</a> 定义的主动方 (active party)不仅是数据提供方，同时拥有样本特征和样本标签，此外还扮演着协调者的角色，计算每个树节点的最佳分割。 而<a href="http://arxiv.org/abs/1901.08755">文献</a>定义的被动方(passive party)只是数据提供者，只提供样本特征，没有样本标签。因此，被动方需要和主动方共同地建构模型来预测标签。</p><p><img src="/images/%E8%81%9A%E5%90%88%E6%A2%AF%E5%BA%A6%E7%BB%9F%E8%AE%A1%E5%80%BC.png" alt="5-1"></p><p><img src="/images/%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BC%98%E5%88%86%E5%89%B2.png" alt="5-2"></p><p>以下步骤是 SecureBoost 算法中一棵树的训练过程：</p><p><img src="/images/%E6%AD%A5%E9%AA%A41.png" alt="步骤1"></p><p><img src="/images/%E6%AD%A5%E9%AA%A42.png" alt="步骤2"></p><p>当完成当前树的构建时，可以计算每个叶节点的最佳权值。然后，根据需求继续构建其他的决策树。 </p><p>SecureBoost 的预测过程，即使用已经训练好的模型(分散于各个参与方)，对新的样本或未标注的样本进行分类。新样本的特征也分散于各个参与方中，并且不能对外公开。每个参与方知道自己的特征，但是对其他参与方的特征一无所知。因此，分类过程需要在隐私保护的协议下，由各参与方协调进行。分类过程从主动方的 root 节点开始。</p><p><img src="/images/%E9%A2%84%E6%B5%8B.png" alt="预测"></p><h3 id="迁移联邦学习"><a href="#迁移联邦学习" class="headerlink" title="迁移联邦学习"></a>迁移联邦学习</h3><p>横向联邦学习和纵向联邦学习要求所有的参与方具有相同的特征空间或样本空间，从而建立起一个有效的共享机器学习模型。然而，在更多的实际情况下，各个参与方所拥有的数据集可能存在高度的差异：</p><ul><li>参与方的数据集之间可能只有少量的重叠样本和特征。 </li><li>这些数据集的分布情况可能差别很大。 </li><li>这些数据集的规模可能差异巨大。 </li><li>某些参与方可能只有数据，没有或只有很少的标注数据。</li></ul><p>为了解决这些问题，联邦学习可以结合迁移学习技术，使其可以应用于更广 的业务范围，同时可以帮助只有少量数据(较少重叠的样本和特征)和弱监督(较少标记)的应用建立有效且精确的机器学习模型，并且遵守数据隐私和安全条例的规定。将这种组合称为联邦迁移学习，它可以处理超出现有横向联邦学习和纵向联邦学习能力范围的问题。</p><h4 id="联系迁移学习的分类与定义"><a href="#联系迁移学习的分类与定义" class="headerlink" title="联系迁移学习的分类与定义"></a>联系迁移学习的分类与定义</h4><p>迁移学习是一种为跨领域知识迁移提供解决方案的学习技术。在许多应用中，只有小规模的标注数据或者较弱的监督能力，这导致可靠的机器学习模型并不能被建立起来。在这些情况下，仍然可以通过利用和调适相似任务或相似领域中的模型，建立高性能的机器学习模型。近年来，从图像分类、自然语言理解到情感分析，越来越多的研究将迁移学习应用于各种各样的领域中。迁移学习的性能依赖于领域之间的相关程度，目前人们提出了许多用来测量领域相似度的理论模型。</p><p>迁移学习的本质是发现资源丰富的源域(source domain)和资源稀缺的目标域 (target domain)之间的不变性(或相似性)，并利用该不变性在两个领域之间传输知识。基于执行迁移学习的方法，迁移学习主要分为三类：基于实例的迁移、基于特征的迁移和基于模型的迁移。联邦迁移学习将传统的迁移学习扩展到了面向隐私保护的分布式机器学习范式中。</p><ol><li>基于实例的联邦迁移学习</li></ol><p>对于横向联邦学习，参与方的数据通常来自不同的分布，这可能会导致在这些数据上训练的机器学习模型的性能较差。参与方可以有选择地挑选或者加权训练样本，以减小分布差异，从而可以将目标损失函数最小化。对于纵向联邦学习，参与方可能具有非常不同的业务目标。因此，对齐的样本及其某些特征可能对联邦迁移学习产生负面影响，这被称为负迁移。在这种情况下，参与方可以有选择地挑选用于训练的特征和样本，以避免产生负迁移。 </p><ol start="2"><li>基于特征的联邦迁移学习</li></ol><p>参与方协同学习一个共同的表征(representation)空间。在该空间中，可以缓解从原始数据转换而来的表征之间的分布和语义差异，从而使知识可以在不同领域之间传递。对于横向联邦学习，可以通过最小化参与方样本之间的最大平均差异 (Maximum Mean Discrepancy, MMD)来学习共同的表征空间。对于纵向联邦学习，可以通过最小化对齐样本中属于不同参与方的表征之间的距离，来学习共同的表征空间。</p><ol start="3"><li>基于模型的联邦迁移学习</li></ol><p>参与方协同学习可以用于迁移学习的共享模型，或者参与方利用预训练模型作为联邦学习任务的全部或者部分初始模型。横向联邦学习本身就是一种基于模型的联邦迁移学习。因为在每个通信回合中，各参与方会协同训练一个全局模型(基于所有数据，并且各参与方把该全局模型作为初始模型进行微调(基于本地数据)。对于纵向联邦学习，可以从对齐的样本中学习预测模型或者利用半监督学习技术，以推断缺失的特征和标签。然后，可以使用扩大的训练样本训练更准确的共享模型。</p><p>联邦迁移学习旨在为以下场景提供解决方案：<br>$$<br>\mathcal{X}_i \neq \mathcal{X}_j ,~<br>\mathcal{Y}_i \neq \mathcal{Y}_j ,~<br>\mathcal{I}_i \neq \mathcal{I}_j ,~<br>\forall \mathcal{D}_i, \mathcal{D}_j, i \neq j,<br>$$<br>式中，$\mathcal{X}_i$ 和 $\mathcal{Y}_i$ 分别表示第 $i$ 方的特征空间和标签空间；$\mathcal{I}_i$ 表示样本空间；$\mathcal{D}_i$ 表示第 $i$ 方拥有的数据集。最终目标是尽可能准确地对目标域中的样本进行标签预测（或回归预测）。</p><p>从技术角度来看，联邦迁移学习和传统的迁移学习主要有以下两方面的不同：</p><ul><li>联邦迁移学习基于分布在多方的数据来建立模型，并且每一方的数据不能集中到一起或公开给其他方。传统迁移学习没有这样的限制。</li><li>联邦迁移学习要求对用户隐私和数据(甚至模型)安全进行保护，这在传统迁移学习中并不是一个主要关注点。</li></ul><p>联邦迁移学习将传统迁移学习带到基于面向隐私保护的分布式机器学习范式中。 因此，下面对一个联邦迁移学习系统所必须保证的安全性进行了定义。</p><blockquote><p><strong>联邦迁移学习系统的安全定义</strong>：一个联邦迁移学习系统一般包括两方，称为源域和目标域。一个多方的联邦迁移学习系统可以被认为是多个两方联邦迁移学习系统的结合。联邦迁移学习假设每一方都是诚实但好奇(honest-but-curious)的。这意味着，联邦中的所有方都遵守联邦的协议和规则，但他们会尝试从收到的数据中推测出尽量多的信息。考虑一个有半诚实敌对方的威胁模型，该敌对方最多可以破坏联邦迁移学习系统中的一方。对于一个表示为$(O_A,O_B)&#x3D;P(I_A,I_B)$的协议 P，其中 $O_A$ 和 $O_B$ 分别是 A 方和 B 方的输出，$I_A$ 和 $I_B$ 分别是它们的输入，如果存在无穷多个 $(I_B^{‘},O_B^{‘})$ 对，使得 $(O_A,O_B^{‘})&#x3D;P(I_A,I_B^{‘})$，则 P 对 A 方是安全的。</p></blockquote><h4 id="联邦迁移学习框架"><a href="#联邦迁移学习框架" class="headerlink" title="联邦迁移学习框架"></a>联邦迁移学习框架</h4><p><img src="/images/6-1.png" alt="6-1"></p><p><img src="/images/6-2.png" alt="6-2"></p><p>在迁移联邦学习中，需要用隐私保护方法来计算参数。最常用的两种方式，一种基于同态加密，另一种基于秘密共享。加法同态加密（AHE）和多项式近似已被广泛应用于面向隐私保护的机器学习中。</p><h3 id="联邦学习激励机制"><a href="#联邦学习激励机制" class="headerlink" title="联邦学习激励机制"></a>联邦学习激励机制</h3><p>联邦学习激励机制（Federated Learning Incentivizer，FLI）的任务目标为最大化联邦的可持续性经营，同时最小化参与方间的不公平性，动态的将给定的预算分配给联邦中的各个参与方，还可以扩展为一种能够帮助联邦抵制恶意的参与方的调节机制。</p><h4 id="贡献的收益"><a href="#贡献的收益" class="headerlink" title="贡献的收益"></a>贡献的收益</h4><p>对于联邦而言，参与方持续地参与到联邦的学习进程(例如,通过共享加密的模型参数)是其长期成功的关键所在。参与方加入联邦，构建一个机器学习模型，从而对联邦作出贡献，训练出的模型可以产生收益。联邦可以与参与方们共享部分收益，以此作为激励，如下图所示。这里的研究问题是，如何以情境感知等方式量化每个参与方为联邦带来的收益，从而实现联邦长期的可持续经营。</p><p><img src="/images/7-1.png" alt="7-1"></p><h5 id="收益分享博弈"><a href="#收益分享博弈" class="headerlink" title="收益分享博弈"></a>收益分享博弈</h5><p>一般而言，广泛使用的收益分享方法可以分为三类。</p><ol><li><strong>平等</strong>。由数据联邦产生的任何效用，都平均分配给帮助生成它的参与方。</li><li><strong>边际收益</strong>。数据联邦中的参与方的效益是它加入团队时所产生的效用。</li><li><strong>边际损失</strong>。数据联邦中的参与方的效益是它离开团队时所产生的效用。</li></ol><h5 id="反向拍卖"><a href="#反向拍卖" class="headerlink" title="反向拍卖"></a>反向拍卖</h5><p>除了基于收益分享博弈的方法，反向拍卖还能被用来制定激励计划，以提高各参与方所贡献的数据的质量。目前,已经有了用于传感器数据的反向拍卖方法，该方法的目的是在提供有质量的数据前提下，寻求最低廉的传感器组合方式。这类方法基于一种假设，即中央实体清楚自己需要何种数据(例如地理分布)。然而，这类方法通常假设数据质量与成本或代价无关(因为反向拍卖需要相同的物品)。一种不好的结果是，参与方可能仅仅为了获取回报，而提交不具有信息的数据来套利。另一种获取指定质量的数据的方法是发布奖励，这是一种只能接受或放弃的方法。联邦可以发布一个固定额度的奖励，以奖励那些能够贡献具有指定质量的数据的参与方。如果需要付出的代价低于能够得到的回报奖励，参与方可以选择参与到联邦模型训练中去；或者如果代价高于能够得到的奖励，则参与方可以不参与。当需要参于方的努力以满足数据的质量需求时，可以有三种奖励设计方案。</p><ul><li>通过输出协议</li><li>通过信息理论分析</li><li>通过模型改良</li></ul><h4 id="注重公平的收益分享框架"><a href="#注重公平的收益分享框架" class="headerlink" title="注重公平的收益分享框架"></a>注重公平的收益分享框架</h4><p>前面提到的方案可以扩展至参与方们未被预先奖励的情况，但他们必须等待联邦模型产生利润，之后才能得到奖励。下面介绍联邦学习系统模型并导出了 FLI 收益分享方案。如下图所示。</p><p><img src="/images/7-2.png" alt="7-2"></p><ul><li>建模贡献</li><li>建模代价</li><li>建模期望损失</li><li>建模时间期望损失</li><li>策略协调(三个公平标准)<ul><li>贡献公平性(Contribution Fairness)。参与方 $i$ 的回报应该与其对联邦 $q_i(t)$ 的贡献明确相关。 </li><li>期望损失分配公平性(Regret Distribution Fairness )。参与方间的期望损失和时间期望损失应该尽可能的小。</li><li>期望公平性(Expectation Fairness)。参与方的期望损失和时间期望损失随时间推移而产生的变化应该尽可能的小。</li></ul></li><li>计算收益评估比重</li></ul><p><img src="/images/7-3.png" alt="7-3"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo config</title>
      <link href="/2021/10/06/hexo-config/"/>
      <url>/2021/10/06/hexo-config/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-config"><a href="#hexo-config" class="headerlink" title="hexo config"></a>hexo config</h2><p>记录使用 hexo 在 Ubuntu 20.04 环境下搭建简易静态博客的过程。</p><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><h4 id="安装前置软件包"><a href="#安装前置软件包" class="headerlink" title="安装前置软件包"></a>安装前置软件包</h4><p>安装 hexo 前需要安装其他使用到的包。安装命令如下：</p><ul><li>安装 git</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p>git 配置与链接远端仓库略</p><ul><li>安装 nodejs 与 npm</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -</span><br><span class="line">sudo apt install nodejs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nodejs 软件包同时包含 node 和 npm 二进制包</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以利用下面两条命令查看版本</span></span><br><span class="line">node --version</span><br><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>其中第一条命令是下载并执行 NodeSource 安装脚本,这个脚本将其签名 key 添加到你的系统,创建一个 apt 源文件,安装必备的软件包,并且刷新 apt 缓存.如果需要另外的 Node.js 版本,例如12.x,将 setup_14.x 修改为 setup_12.x 。</p><ul><li>安装 hexo</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>若提示权限不足，可以使用 <code>sudo</code> 权限执行。</p><h3 id="初始化博客结构"><a href="#初始化博客结构" class="headerlink" title="初始化博客结构"></a>初始化博客结构</h3><p>在终端 cd 到指定目录，执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init [blog_dir_name]# 最后的参数是初始化博客结构的总目录的名称</span><br><span class="line">cd [blog_dir_name]</span><br><span class="line">npm install# 使用 npm 安装相关包</span><br><span class="line">hexo server# 在本地搭建预览，可在浏览器访问预览：://127.0.0.1:4000</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml# 配置文件</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds# 存放一些模板类文件</span><br><span class="line">├── source# 存放博客源文件</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes# 存放主题</span><br></pre></td></tr></table></figure><p><code>_config.yml</code> 配置文件详细指南可查看<a href="https://hexo.io/zh-cn/docs/configuration">官方文档</a> ，内容不复杂，一般只进行少许修改即可。</p><h3 id="装载-snark-主题"><a href="#装载-snark-主题" class="headerlink" title="装载 snark 主题"></a>装载 snark 主题</h3><p>克隆主题文件到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litreily/hexo-theme-snark.git [blog_dir_name]/themes/snark</span><br></pre></td></tr></table></figure><p>安装相关依赖(在博客目录内使用)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 配置文件中进行部分修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>创建几个可选的功能页面(也在博客目录内使用)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new page archives</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h3 id="推送到远端仓库"><a href="#推送到远端仓库" class="headerlink" title="推送到远端仓库"></a>推送到远端仓库</h3><p>只使用 <code>serve</code> 命令只能在本地预览，要使用其他命令来将博客文件部署到仓库，或者将生成的所有静态文件直接推送到仓库。</p><p>相比较来说，后者无需进行任何配置，只是需要每次在更新博客时重新生成静态文件，然后一次次的推送到远端。这些重复性的动作可以使用脚本来代劳，所以执行起来与自动部署的命令相差不多。</p><p>生成静态文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hexo clean &amp;&amp; hexo generate</span></span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>一般在不使用 <code>clean</code> 命令时可以使用 <code>-f</code> 参数 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p>静态文件会生成在博客目录下的 <code>public</code> 目录中，现在只需要将该目录中的所有文件放入仓库目录，在推送到远端即可。当然，重复的工作可以交给脚本。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://hexo.io/zh-cn/docs">官方文档</a></p><p><a href="https://github.com/Litreily/hexo-theme-snark">snark主题文档</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
